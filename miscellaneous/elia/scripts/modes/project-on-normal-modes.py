#!/usr/bin/env python
import argparse
import pickle
import xarray as xr
from miscellaneous.elia.output import output_folder
from miscellaneous.elia.normal_modes import NormalModes
from miscellaneous.elia.trajectory import trajectory as Trajectory
from miscellaneous.elia.units import remove_unit

# import warnings
# warnings.filterwarnings("error")
#---------------------------------------#
# Description of the script's purpose
description = "Project a trajectory onto the normal modes computed by i-PI."
warning = "***Warning***"
closure = "Job done :)"
keywords = "It's up to you to modify the required keywords."
input_arguments = "Input arguments"
#---------------------------------------#
# colors
try :
    import colorama
    from colorama import Fore, Style
    colorama.init(autoreset=True)
    description     = Fore.GREEN  + Style.BRIGHT + description             + Style.RESET_ALL
    warning         = Fore.MAGENTA    + Style.BRIGHT + warning.replace("*","") + Style.RESET_ALL
    closure         = Fore.BLUE   + Style.BRIGHT + closure                 + Style.RESET_ALL
    keywords        = Fore.YELLOW + Style.NORMAL + keywords                + Style.RESET_ALL
    input_arguments = Fore.GREEN  + Style.NORMAL + input_arguments         + Style.RESET_ALL
except:
    pass
#---------------------------------------#
def prepare_args():
    parser = argparse.ArgumentParser(description=description)
    argv = {"metavar":"\b"}
    # parser.add_argument("-g",  "--ground_state", type=str, **argv, help="ground-state atomic structure [a.u.] (default: 'start.xyz')", default="start.xyz")
    parser.add_argument("-t" ,  "--trajectory"   , type=str, **argv, help="input extxyz file [a.u.] (default: 'trajectory.extxyz')", default="trajectory.extxyz")
    parser.add_argument("-nm", "--normal_modes"  , type=str, **argv, help="normal modes file generated by 'iPI2NormalModes.py'")
    parser.add_argument("-o" ,  "--output"       , type=str, **argv, help="output file (default: 'projected.pickle')", default="projected.pickle")
    parser.add_argument("-of",  "--output_folder", type=str, **argv, help="output folder for csv files (default: 'None')", default=None)
    return parser.parse_args()

def main():

    #------------------#
    # Parse the command-line arguments
    args = prepare_args()

    # Print the script's description
    print("\n\t{:s}".format(description))

    print("\n\t{:s}:".format(input_arguments))
    for k in args.__dict__.keys():
        print("\t{:>20s}:".format(k),getattr(args,k))
    print()

    # #---------------------------------------#
    # # read trajectory
    # print("\tReading trajectory from file '{:s}' ... ".format(args.trajectory), end="")
    # atoms = read(args.trajectory,format="extxyz",index=":")
    # print("done")

    # print("\tVectorizing the trajectory ... ", end="")
    # trajectory = easyvectorize(Atoms)(atoms)
    # del atoms
    # print("done")
    print("\tReading trajectory from file '{:s}' ... ".format(args.trajectory), end="")
    trajectory = Trajectory(args.trajectory)
    print("done")

    #---------------------------------------#
    # read phonon modes ('phonon-modes.pickle')
    print("\tReading phonon modes from file '{:s}' ... ".format(args.normal_modes), end="")
    with open(args.normal_modes,'rb') as f:
        nm = pickle.load(f)
    # pm = NormalModes.read(args.normal_modes,"pickle") # pd.read_pickle(args.normal_modes)
    print("done")

    if type(nm) != NormalModes:
        raise TypeError("Loaded object is of wrong type, it should be a 'NormalModes' object")

    #---------------------------------------#
    # project on phonon modes
    print("\n\tProjecting the trajectory:")
    results = nm.project(trajectory,warning)
    # results.at[q,"q"] = q
    # for c in out.keys():
    #     if c not in results.columns:
    #         results[c] = None
    #     results.at[q,c] = out[c]
    print("done")
    # results = pd.DataFrame(index=pm.index,columns=["q"])
    # k = 0
    # for n,row in pm.iterrows():
    #     q = row["q"]
    #     print("\t\t- phonon modes {:d} with q-point {:s} ... ".format(k,str(q)), end="")
    #     if type(row["supercell"]) != NormalModes:
    #         raise TypeError("'supercell' element is of wrong type, it should be a 'NormalModes' object")     
    #     # row["modes"].write("test.yaml","yaml")   
    #     out = row["supercell"].project(trajectory)
    #     results.at[q,"q"] = q
    #     for c in out.keys():
    #         if c not in results.columns:
    #             results[c] = None
    #         results.at[q,c] = out[c]
    #     print("done")
    #     k += 1
        
    #---------------------------------------#
    # save result to file
    print("\n\tWriting results to file '{:s}' in pickle format ... ".format(args.output), end="")
    # Open the file in binary write mode ('wb')
    with open(args.output, 'wb') as file:
        # Use pickle.dump() to serialize and save the object to the file
        pickle.dump(results, file)
    print("done")

    if args.output_folder is not None:
        print("\n\tWriting results to folder '{:s}' in separated csv files:".format(args.output_folder))
        output_folder(args.output_folder,show=False)
        for k in results.keys():
            arr = xr.DataArray(results[k])
            # if not isinstance(results[k],xr.DataArray):
            #     raise TypeError("results[{:s}] is of wrong type, it should be a 'xarray.DataArray' object".format(k))
            file = "{:s}/{:s}.csv".format(args.output_folder,k)
            print("\t\tsaving '{:s}' to file '{:s}' ... ".format(k,file), end="")
            arr = remove_unit(arr)[0]
            # dims = list(arr.dims)
            # dims.remove('time')
            # arr = arr.reorder_levels(['time',*dims])

            df = arr.T.to_pandas()
            df.to_csv(file,index=False,header=False,na_rep="nan",float_format="%24.16f")
            print("done")

        print("\n\tHow to read the csv files:")
        print("\t\tcolumns: normal mode index")
        print("\t\t   rows: time step")

    #---------------------------------------#
    # Script completion message
    print("\n\t{:s}\n".format(closure))

if __name__ == "__main__":
    main()