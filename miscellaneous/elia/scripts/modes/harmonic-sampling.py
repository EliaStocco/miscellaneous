#!/usr/bin/env python
import argparse
import pickle
from miscellaneous.elia.classes.normal_modes import NormalModes
from ase.io import read, write
from miscellaneous.elia.functions import convert
from miscellaneous.elia.units import remove_unit
from ase import Atoms
import numpy as np
import xarray as xr

# import warnings
# warnings.filterwarnings("error")
#---------------------------------------#
# Description of the script's purpose
description = "Perform an harmonic sampling of the PES using the vibrational modes."
warning = "***Warning***"
closure = "Job done :)"
error = "***Error***"
keywords = "It's up to you to modify the required keywords."
input_arguments = "Input arguments"
#---------------------------------------#
# colors
try :
    import colorama
    from colorama import Fore, Style
    colorama.init(autoreset=True)
    description     = Fore.GREEN  + Style.BRIGHT + description             + Style.RESET_ALL
    warning         = Fore.MAGENTA    + Style.BRIGHT + warning.replace("*","") + Style.RESET_ALL
    closure         = Fore.BLUE   + Style.BRIGHT + closure                 + Style.RESET_ALL
    error           = Fore.RED      + Style.BRIGHT + error.replace("*","")   + Style.RESET_ALL
    keywords        = Fore.YELLOW + Style.NORMAL + keywords                + Style.RESET_ALL
    input_arguments = Fore.GREEN  + Style.NORMAL + input_arguments         + Style.RESET_ALL
except:
    pass
#---------------------------------------#
def prepare_args():
    parser = argparse.ArgumentParser(description=description)
    argv = {"metavar":"\b"}
    parser.add_argument("-r" , "--reference"   , type=str  , **argv, help="ground-state atomic structure [a.u.] (default: None)", default=None)
    parser.add_argument("-nm", "--normal_modes", type=str  , **argv, help="normal modes file generated by 'iPI2NormalModes.py'")
    parser.add_argument("-d" , "--dof"         , type=int  , **argv, help="dof to be skipped (default: 3)", default=3)
    parser.add_argument("-t" , "--temperature" , type=float, **argv, help="temperature [K] (default: 300)", default=300)
    parser.add_argument("-n" , "--number"      , type=int  , **argv, help="number of samples (default: 100)", default=100)
    parser.add_argument("-s" , "--std"         , type=float, **argv, help="standard deviation of the normal distribution (default: 1)", default=1.)
    parser.add_argument("-o" , "--output"      , type=str  , **argv, help="output file (default: 'output.xyz')", default='output.xyz')
    return parser.parse_args()

def main():

    #------------------#
    # Parse the command-line arguments
    args = prepare_args()

    # Print the script's description
    print("\n\t{:s}".format(description))

    print("\n\t{:s}:".format(input_arguments))
    for k in args.__dict__.keys():
        print("\t{:>20s}:".format(k),getattr(args,k))
    print()

    #---------------------------------------#
    # read phonon modes ('phonon-modes.pickle')
    print("\tReading phonon modes from file '{:s}' ... ".format(args.normal_modes), end="")
    with open(args.normal_modes,'rb') as f:
        nm = pickle.load(f)
    # pm = NormalModes.read(args.normal_modes,"pickle") # pd.read_pickle(args.normal_modes)
    print("done")

    if type(nm) != NormalModes:
        raise TypeError("Loaded object is of wrong type, it should be a 'NormalModes' object")
    
    #---------------------------------------#
    # read reference atomic structure
    reference = None
    if args.reference is not None:
        print("\tReading reference atomic structure from input '{:s}' ... ".format(args.reference), end="")
        reference = read(args.reference)
        print("done")
    
        nm.reference = reference

    if nm.reference is None:
        print("\n\t{:s}: no reference structure provided.\nSpecify it with -r,--reference.".format(error))
        return
    
    nm.eigvec2modes()

    #---------------------------------------#
    # temperature
    T = convert(args.temperature,"temperature","kelvin","atomic_unit")
    print("\n\tConverting temperature: {:.2f}K = {:.2e}au".format(args.temperature,T))

    #---------------------------------------#
    
    symbols = nm.reference.get_chemical_symbols()
    Natoms = nm.reference.positions.shape[0]
    atoms = [None]*args.number
    w2 = np.absolute(nm.eigval)
    Amp = np.sqrt( 2 * T / w2 )

    freq = convert(np.sqrt(w2),"frequency","atomic_unit","terahertz")
    print("\n\tFrequencies [THz]: ")
    print("\t|{:>3s}  |{:^8s}   |{:^6s}|{:^8s}   |".format("n","Ï‰","skip","A"))
    line="-"*36
    print("\t|{:s}|".format(line))
    for n,f in enumerate(freq):
        yesno = n < args.dof
        A = Amp[n] if not yesno else np.nan
        yesno = 'yes' if yesno else 'no'
        print("\t|{:>3d}  |{:>8.3f}   |{:^6s}|{:>8.3f}   |".format(n,f,yesno,A))
    print("\t|{:s}|".format(line))

    print("\n\tSampling datastructure ... ",end="")
    displ = Amp[args.dof:] * nm.mode.T.real[args.dof:]
    for n in range(args.number):
        # cos = np.random.uniform(-1, 1, size=nm.Nmodes)
        # cos = np.cos(np.random.uniform(0,2*np.pi, size=nm.Nmodes))
        xsi = np.random.normal(0, args.std, size=len(displ))
        xsi = xr.DataArray(xsi, dims=('mode'))
        modes = xsi * displ
        # modes = modes[args.dof:]
        pos = modes.sum("mode")#+ nm.reference
        pos, _ = remove_unit(pos)
        pos = np.asarray(pos).reshape((Natoms,3)) + nm.reference.positions
        atoms[n] = Atoms(positions=pos,symbols=symbols,cell=nm.reference.get_cell(),pbc=reference.get_pbc())
    print("done")

    #---------------------------------------#
    # Write the data to the specified output file with the specified format
    print("\n\tWriting data to file '{:s}' ... ".format(args.output), end="")
    try:
        write(images=atoms,filename=args.output)
        print("done")
    except Exception as e:
        print("\n\tError: {:s}".format(e))

    #---------------------------------------#
    # Script completion message
    print("\n\t{:s}\n".format(closure))

if __name__ == "__main__":
    main()