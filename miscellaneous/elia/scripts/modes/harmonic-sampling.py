#!/usr/bin/env python
import argparse
from miscellaneous.elia.input import str2bool
from miscellaneous.elia.classes.normal_modes import NormalModes
from ase.io import read, write
from miscellaneous.elia.tools import convert
import numpy as np
import xarray as xr

#---------------------------------------#
# Documentation:
# - https://vibes-developers.gitlab.io/vibes/Tutorial/4_statistical_sampling/

# import warnings
# warnings.filterwarnings("error")
#---------------------------------------#
# Description of the script's purpose
description = "Perform an harmonic sampling of the PES using the vibrational modes."
warning = "***Warning***"
closure = "Job done :)"
error = "***Error***"
keywords = "It's up to you to modify the required keywords."
input_arguments = "Input arguments"
#---------------------------------------#
# colors
try :
    import colorama
    from colorama import Fore, Style
    colorama.init(autoreset=True)
    description     = Fore.GREEN  + Style.BRIGHT + description             + Style.RESET_ALL
    warning         = Fore.MAGENTA    + Style.BRIGHT + warning.replace("*","") + Style.RESET_ALL
    closure         = Fore.BLUE   + Style.BRIGHT + closure                 + Style.RESET_ALL
    error           = Fore.RED      + Style.BRIGHT + error.replace("*","")   + Style.RESET_ALL
    keywords        = Fore.YELLOW + Style.NORMAL + keywords                + Style.RESET_ALL
    input_arguments = Fore.GREEN  + Style.NORMAL + input_arguments         + Style.RESET_ALL
except:
    pass
#---------------------------------------#
def prepare_args():
    parser = argparse.ArgumentParser(description=description)
    argv = {"metavar":"\b"}
    parser.add_argument("-r" , "--reference"   , type=str     , **argv, help="ground-state atomic structure [a.u.] (default: None)", default=None)
    parser.add_argument("-nm", "--normal_modes", type=str     , **argv, help="normal modes file generated by 'ipi2normal-modes.py' (default: 'normal-modes.pickle')", default="normal-modes.pickle")
    parser.add_argument("-d" , "--dof"         , type=int     , **argv, help="dof to be skipped (default: 3)", default=3)
    parser.add_argument("-t" , "--temperature" , type=float   , **argv, help="temperature [K] (default: 300)", default=300)
    parser.add_argument("-n" , "--number"      , type=int     , **argv, help="number of samples (default: 100)", default=100)
    parser.add_argument("-s" , "--seed"        , type=int     , **argv, help="seed of the random number generator: specify a number for reproducibility (default: None)", default=None)
    parser.add_argument("-o" , "--output"      , type=str     , **argv, help="output file (default: 'output.xyz')", default='output.xyz')
    return parser.parse_args()

def main():

    #------------------#
    # Parse the command-line arguments
    args = prepare_args()

    # Print the script's description
    print("\n\t{:s}".format(description))

    print("\n\t{:s}:".format(input_arguments))
    for k in args.__dict__.keys():
        print("\t{:>20s}:".format(k),getattr(args,k))
    print()

    if args.seed is not None:
        print("\n\tSetting the random number generator (numpy) seed to '{:d}' ... ".format(args.seed), end="")
        np.random.seed(args.seed)
        print("done")

    #---------------------------------------#
    print("\tReading phonon modes from file '{:s}' ... ".format(args.normal_modes), end="")
    nm = NormalModes.from_pickle(args.normal_modes)
    print("done")
    
    #---------------------------------------#
    # read reference atomic structure
    reference = None
    if args.reference is not None:
        print("\tReading reference atomic structure from input '{:s}' ... ".format(args.reference), end="")
        reference = read(args.reference)
        print("done")
    
        nm.reference = reference

    if nm.reference is None:
        print("\n\t{:s}: no reference structure provided.\nSpecify it with -r,--reference.".format(error))
        return
    
    if np.any(nm.eigval) < -1e-4:
        raise NotImplementedError("this script has not implemented yet for negative eigenvalues.")

    #---------------------------------------#
    # temperature
    T = convert(args.temperature,"temperature","kelvin","atomic_unit")
    print("\n\tConverting temperature: {:.2f}K = {:.2e}au".format(args.temperature,T))

    #---------------------------------------#
    atoms = [None]*args.number
    w2 = np.absolute(nm.eigval)
    Amp = np.sqrt( 2 * T / w2 )

    freq = convert(np.sqrt(w2),"frequency","atomic_unit","terahertz")
    line="-"*36
    #print("\n\tFrequencies [THz]: ")
    print("\n\t|{:s}|".format(line))
    print("\t|{:>3s}  |{:^8s}   |{:^6s}|{:^8s}   |".format("n","Ï‰ [THz]","used","A"))
    print("\t|{:s}|".format(line))
    for n,f in enumerate(freq):
        yesno = n >= args.dof
        A = Amp[n] if yesno else np.nan
        yesno = 'yes' if yesno else 'no'
        print("\t|{:>3d}  |{:>8.3f}   |{:^6s}|{:>8.3f}   |".format(n,f,yesno,A))
    print("\t|{:s}|".format(line))

    print("\n\tSampling atomic structures ... ",end="\r")
    for n in range(args.number):
        print("\tSampling atomic structures ...  {:d}/{:d}".format(n+1,args.number),end="\r")
        xsi = np.random.normal(0, 1, size=len(Amp))
        xsi = xr.DataArray(xsi, dims=('mode'))
        A = xsi * Amp # * np.random.choice([-1, 1],len(Amp))
        A[:args.dof] = 0
        structure = nm.ed2cp(A)
        atoms[n] = structure.copy()
    print("\tSampling atomic structures ... done")

    #---------------------------------------#
    print(  "\n\t{:s} in case you were dealing with a periodic structure:" \
            "\n\t1) it's recommended to fold the structures within the primitive cell" \
            "by using the 'fold.py' script"\
            "\n\t2) or to unfold to have a cleaner visual output"\
            "by using the 'unfold.py' script".format(warning))

    #---------------------------------------#
    # Write the data to the specified output file with the specified format
    print("\n\tWriting data to file '{:s}' ... ".format(args.output), end="")
    try:
        write(images=atoms,filename=args.output)
        print("done")
    except Exception as e:
        print("\n\tError: {:s}".format(e))

    #---------------------------------------#
    # Script completion message
    print("\n\t{:s}\n".format(closure))

if __name__ == "__main__":
    main()